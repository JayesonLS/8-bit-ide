; Test PIO program for outputting data with approximate ISA timing.
;
; Copyright (C) 2021 Titanium Studios Pty Ltd 
; 
; This program is free software : you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program.If not, see < https://www.gnu.org/licenses/>.

; At 125MHz, 8ns per instruction.
; Allowing for aliasing delay and two LVC propogation delays,
; max instructions to set up a read is 23.

; Possible pin reorder
;        uint data : num_data_bits;
;        uint inv_dack : 1;
;        uint inv_iow : 1; ; TODO: Update all programs for ~IOW being before ~IOR
;        uint inv_ior : 1;
;        uint inv_cs : 1;
;        uint aen : 1;
;        uint a1 : 1; TODO: Update most programs to account for A0/A1 reverse order.
;		 uint a0 : 1; 
;        uint drq : 1;
;        uint irq : 1;
;
;		 uint data_dir : 1;
;
;        uint inv_reset : 1;

;-----------------------------------------------------------------------------------------
; *************** No good - timing too long ********************************************** 
; TODO: Need to be careful not to pump values into FIFO too quickly. On select, program
; will generate an IRQ. If another value gets pushed into the FIFO after, it will override
; the busy flags.

; TODO: We are one instruction over. May need to remove the replication of the busy variant
; flags (the two in osr, 16). This will mean that a second select before the CPU respons would
; start returning all zeros. 

; Maybe dedicate an entire CPU to checking for this IRQ? Its whole job could be to push 
; a busy variant of the flags into the FIFO. There may be some tricky race conditions to
; deal with. Something to check the timing of.

; TODO: This is no good - about 28 instructions to set up read which is too long.
.program control_regs
.side_set 1 opt
    ; This program *MUST* be started at the wrap target.

address_1_write:
    ; Reset controller.
    irq wait 0      ; Trigger reset interupt and halt the program 

address_2_write:
    ; Select controller.
    irq 1           ; Trigger select interrupt.
    pull noblock    ; Get latest value from FIFO if any, otherwise X -> OSR
    out null, 16    ; Switch to busy variant of flags
;    in osr, 16
;    in osr, 16
;    mov x, isr
    mov x, osr

    wait 1 pin 10   ; Wait for ~IOW high.
    ; Fall through to wrap target.

.wrap_target
wait_for_read_or_write:
    pull noblock    ; Keep read values up to date. If FIFO is empty,
    mov x, osr      ; X is moved to OSR. Hold read values in X.
    mov osr, pins
    out null, 12    ; Skip data, ~DACK and ~IOR
    out y, 1        ; ~IOW to Y (want 0)
    jmp !y read_or_write_start
    jmp pin wait_for_read_or_write  ; Jump if ~IOR high.

read_or_write_start:
    out y, 2        ; ~CS and AEN to Y (want both 0)
    jmp y-- wait_for_read_or_write
    out y, 2        ; Address to Y
    jmp y-- wait_for_read_or_write ; Jump if address = 0
    mov osr, x      ; Get data into X. Low 8 bits is address 1 value, next 8 bits is address 2 value. 
    jmp y-- not_address_1          ; Jump if address 2 or 3

address_1:
    ; Read or write to address = 1.
    jmp pin address_1_write ; If ~IOR high, ~IOW must be low
address_1_read:
    jmp do_read

not_address_1:
    jmp y-- wait_for_read_or_write ; Jump if address 3.
address_2:
    jmp pin address_2_write ; If ~IOR high, ~IOW must be low
address_2_read:
    out null, 8     ; Skip low 8 bits to get address 1 value

do_read:
    mov osr, x side 1  ; Get data, change tranceiver direction
    out pins, 8         ; Set data
    mov osr, ~null
    out pindirs, 8      ; Set pindirs
    mov osr, null
    wait 1 pin 9        ; Wait for ~IOR high
    out pindirs, 8 side 0 ; Disable outputs and restore tranceiver direction.
.wrap

;-----------------------------------------------------------------------------------------
; This approach to implementation requires the CPU to very quickly update
; the read value for register 1 to indicate busy. Should probably dedicate a CPU to this.
; TODO: We must start this program at the "wait 1 pin 10" line (one before the wrap target)
; 17 instructions.

.program write_control_regs
write_address_2:
    ; Write to address 2 is select controller
    irq 1							; Trigger select interrupt
    wait 1 pin 10                   ; Wait for ~IOW high

.wrap_target
wait_for_write_start:
    wait 0 pin 10                   ; Wait for ~IOW low
    mov osr, pins
    out null, 12					; Skip data, ~DACK, ~IOR and ~IOW
    out y, 2						; ~CS and AEN to Y (want both 0)
    jmp y-- wait_for_write_start
    out y, 2						; Address to Y
    jmp y-- wait_for_write_start	; Jump if address = 0
    jmp y-- not_address_1			; Jump if address 2 or 3

write_address_1:
    ; Write to address 1 is reset controller
    irq wait 0						; Trigger reset interupt and halt the program 

not_address_1:
    jmp !y write_address_2			; Jump if address 2

write_address_3:
    ; Write to address 2 is the DMA/IRQ enable bits.
wait_for_write_end:
    mov osr, pins
    jmp pin write_value				; Break if ~IOW has gone high.
    mov isr, osr                    ; Update previous value
    jmp wait_for_write_end

write_value:
    ; TODO: Should we clear IRQ here if the value is cleared? Same for DRQ?
    ; If we don't need to be clearing DRQ/IRQ, then we can let write_address_2 fall through
    ; to write_address_3 and remove a couple of instructions. 
    push block						; Send the last value read before ~IOW went high.

;-----------------------------------------------------------------------------------------
; Register 1 is the flags register.
;
; Note: We must constantly pull from the FIFO to keep the
; register value up to date.
;
; 13 instructions.
; Up to 13 cycle delay to set up data (+ ~4 cycles in external delays)
; Allowed delay ~25 cycles with 125MHz Pico & 10MHz ISA bus
;-----------------------------------------------------------------------------------------
.program read_register_1
.side_set 3 opt						; Low to high: 22 data_dir, 23 vreg_mode (always 0), 24 end_read_signal

wait_for_read_start:
    pull noblock					; Keep read values up to date. If FIFO is empty,
    mov x, osr						; X is moved to OSR. So save read values in X.
    ; For 1 cycle lower latency is needed we can do a "jmp pin wait_for_read_start" here.
    mov osr, pins					; in pins are configured to start at ~IOR
    out y, 4						; Shift ~IOR, ~CS, AEN and A1 into Y (want all 0)
    jmp y-- wait_for_read_start
    out y, 1						; Shift A0 into Y
    jmp !y wait_for_read_start		; Jump if address not 1
    
do_read:
    in osr, 2  						; Shift in DRQ and IRQ from OSR
    in x, 4	side 1					; Shift in the 4 status bits from X, reverse tranceiver direction (also signals pindir change)
    mov osr, isr					; (Setting tranceiver direction will result in other program setting pindirs)
    out pins, 8						; Set data. Should be at same time as pindirs changing.
    wait 1 pin 9					; Wait for ~IOR high
    nop side 5        				; Signal to restore pindirs and tranceiver direction (don't change tranceiver direction ourselves).

; Waits for data_dir to go high and then sets pindirs accordingly.
.program set_pindirs
.side_set 3 opt pindirs				; The 3 bits are pindirs for D6-D8
	wait 1 pin 0 [1]				; Wait on data_dir to go high (pin 22), then delay an extra cycle to give 
                                    ; tranceiver plenty of time to reverse. Output data won't be ready earlier anyway.
	set pindirs, 31 side 7			; Pindirs set to out for all 8 data bits
	wait 1 pin 2					; Wait for signal to reverse pindirs (repurposed pin 24)
	set pindirs, 0 side 0			; Restore all pindirs.
	mov pins, null					; Restore data_dir (tranceiver direction) 

;-----------------------------------------------------------------------------------------
; Register 2 is a configuration register. We don't need
; to constantly keep the FIFO empty. In fact we might want to
; send an ID sequence through the top bit.
; Setup code should init X to 0x0000FFFF to handle the case where
; the FIFO is accidentally empty.
; 12 instructions.
.program read_register_2
.side_set 1 opt
wait_for_read_start:
    wait 0 pin 9					; Wait for ~IOR low
    mov osr, pins
    out null, 12					; Skip data, ~DACK, ~IOR and ~IOW
    out y, 3						; ~CS, AEN and A0 to Y (want all 0)
    jmp y-- wait_for_read_start
    out y, 1						; A1 to Y (want 1)
    jmp !y wait_for_read_start

do_read:
    pull noblock side 1				; Get data and change tranceiver direction. We will use DMA/interrupt
                                    ; to constantly feed the FIFO to avoid having to save the value to X.
    out pins, 8						; Set data
    out pindirs, 8					; Set pindirs (high bits are in the next 8 bits of data.)
    wait 1 pin 9					; Wait for ~IOR high
    out pindirs, 8 side 0			; Restore pindirs and tranceiver direction. (low bits are in the next 8 bits of data.)
.wrap

;-----------------------------------------------------------------------------------------
.program write_address_1_external_decode
wait_for_write:
    wait 0 pin 10					; Wait for ~IOW low
    jmp pin wait_for_write			; Wait for decode to go low
    irq wait 0						; Trigger reset interupt and halt the program 

.program write_address_2_external_decode
wait_for_write:
    wait 0 pin 10					; Wait for ~IOW low
    jmp pin wait_for_write			; Wait for decode to go low
    irq 1							; Trigger select interupt
    wait 1 pin 10					; Wait for ~IOW high

.program read_register_external_decode_assume_fifo_clear_safe
.side_set 1 opt
wait_for_read_start:
    wait 0 pin 9					; Wait for ~IOR low
    jmp pin wait_for_read_start     ; Wait for decode to go low

do_read:
    pull noblock side 1				; Get data and change tranceiver direction.
    mov x, osr						; Store "previous value in X".
    out pins, 8						; Set data
    out pindirs, 8					; Set pindirs  (high pindirs in next 8 bits)
    wait 1 pin 9					; Wait for ~IOR high
    out pindirs, 8 side 0			; Restore pindirs and tranceiver direction. (low pindirs in next 8 bits)