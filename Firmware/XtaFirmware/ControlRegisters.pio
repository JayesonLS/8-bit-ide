; Test PIO program for outputting data with approximate ISA timing.
;
; Copyright (C) 2021 Titanium Studios Pty Ltd 
; 
; This program is free software : you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program.If not, see < https://www.gnu.org/licenses/>.

; At 125MHz, 8ns per instruction.
; Max read setup time is 192ns = 24 cycles. Subtract 4 cycles for
; aliasing delay, two LVC propogation delays, and  possibly one Pico
; propogation delay (4 cycles)
; Therefore max instructions to set up a read is 20.

; Proposed pin ordering
;        uint data : num_data_bits;
;		 uint data_dir : 1; data_dir here in case we want to side-set it with some pindirs.
;        uint inv_dack : 1;
;        uint inv_iow : 1; ; TODO: Update all programs for ~IOW being before ~IOR
;        uint inv_ior : 1;
;        uint inv_cs : 1;
;        uint aen : 1;
;        uint a1 : 1; TODO: Update most programs to account for A0/A1 reverse order.
;		 uint a0 : 1; 
;        uint drq : 1;
;        uint irq : 1;
;
;        uint inv_reset : 1;

; Proposed allocations:
; PIO0 = write_control_regs (17) + read_register_1 (13) = 30 instructions
; Can afford to add optional instruction to read_register_1 to save a cycle of latency.
; PIO1 = read_register_2 (11) + set_pindirs (5) = 16 instructions, 
; Leaves 16 for data register program in PIO1.
;
; If we need more for data register program, should remove set_pindirs which will
; add 1 instruction/cycle of latency to each of the read_registers. This will give the
; following sizes:
; PIO0 = write_control_regs (17) + read_register_1 (14) = 31 instructions
; Can afford to add optional instruction to read_register_1 to save a cycle of latency.
; PIO1 = read_register_2 (12) = 12 instructions, 
; Leaves 20 for data register program in PIO1.

;-----------------------------------------------------------------------------------------
; This approach to implementation requires the CPU to very quickly update
; the read value for register 1 to indicate busy. Should probably dedicate a CPU to this.
; TODO: We must start this program at the "wait 1 pin 10" line (one before the wrap target)
; 17 instructions.
;
; We should skip the first instruction on program start.
;-----------------------------------------------------------------------------------------
.program write_control_regs
write_address_2:
    ; Write to address 2 is select controller
    irq nowait 1				    ; Trigger select interrupt
    wait 1 pin 10                   ; Wait for ~IOW high

.wrap_target
wait_for_write_start:
    wait 0 pin 10                   ; Wait for ~IOW low
    mov osr, pins
    out null, 12					; Skip data, data_dir, ~DACK, ~IOW and ~IOR
    out y, 2						; ~CS and AEN to Y (want both 0)
    jmp y-- wait_for_write_start
    out y, 2						; Address to Y
    jmp y-- wait_for_write_start	; Jump if address = 0
    jmp y-- not_address_1			; Jump if address 2 or 3

write_address_1:
    ; Write to address 1 is reset controller
    irq wait 0						; Trigger reset interupt and halt the program 

not_address_1:
    jmp !y write_address_2			; Jump if address 2

write_address_3:
    ; Write to address 2 is the DMA/IRQ enable bits.
wait_for_write_end:
    mov osr, pins
    jmp pin write_value				; Break if ~IOW has gone high.
    mov isr, osr                    ; Update previous value
    jmp wait_for_write_end

write_value:
    ; TODO: Should we clear IRQ here if the value is cleared? Same for DRQ?
    ; If we don't need to be clearing DRQ/IRQ, then we can let write_address_2 fall through
    ; to write_address_3, move the push block to the top and remove the bottom jump.
    ; (Save 2 instructions) 
    push block						; Send the last value read before ~IOW went high.

;-----------------------------------------------------------------------------------------
; Register 1 is the flags register.
;
; Note: We must constantly pull from the FIFO to keep the
; register value up to date.
;
; 13 instructions. Up to 13 cycle delay (+ external delays) to set up read.
; See top of file for a discussion on max delays. 
;-----------------------------------------------------------------------------------------
.program read_register_1
.side_set 1 opt						; Side set maps to data_dir

wait_for_read_start:
    pull noblock					; Keep read values up to date. If FIFO is empty,
    mov x, osr						; X is moved to OSR. So save read values in X.
    ; For 1 cycle lower worst case latency we can do a "jmp pin wait_for_read_start" here on ~IOR.
    mov osr, pins					; in pins are configured to start at ~IOR
    out y, 4						; Shift ~IOR, ~CS, AEN and A1 into Y (want all 0)
    jmp y-- wait_for_read_start
    out y, 1                        ; Shift A0 into Y (want 1)
    jmp !y wait_for_read_start      ; Jump if A0 not 1
    
do_read:
    mov isr, ~osr                   ; Copy with invert ~DRQ and ~IRQ still sitting in OSR
    in x, 4	side 1					; Shift in the 4 status bits from X, reverse tranceiver direction (also signals pindir change)
    mov osr, isr					; (Setting tranceiver direction will result in other program setting pindirs)
    out pins, 8						; Set data.
    wait 1 pin 9					; Wait for ~IOR high
    irq nowait 3                    ; Signal to restore pindirs and tranceiver direction.

;-----------------------------------------------------------------------------------------
; Register 2 is a configuration register. We don't need to constantly keep the FIFO empty.
; Instead we will send an ID sequence through the top bit.
; Setup code should init X to somethign known to handle the case where the FIFO is 
; accidentally empty. FF perhaps?
;
; 11 instructions. Up to 8 cycle delay (+ external delays) to set up read.
; See top of file for a discussion on max delays. 
;-----------------------------------------------------------------------------------------
.program read_register_2
.side_set 1 opt
wait_for_read_start:
    wait 0 pin 9					; Wait for ~IOR low
    mov osr, pins					; in pins are configured to start at ~CS
    out y, 2						; ~CS, AEN to Y (want all 0)
    jmp y-- wait_for_read_start
    out y, 2						; Reverse order A0 and A1 to Y (want 0b10 == addr 1)
    jmp y-- wait_for_read_start     ; Jump if A0A1 = 0b00 
    jmp !y wait_for_read_start      ; Jump if A0A1 != 0b01. 0b01 == Address 0b10. 

do_read:
    pull noblock side 1				; Get data and change tranceiver direction. We will use DMA/interrupt
                                    ; to constantly feed the FIFO to avoid having to save the value to X.
                                    ; set_pindirs will change pindirs for us when the tranceiver direction changes.
    out pins, 8						; Set data
    wait 1 pin 9					; Wait for ~IOR high
    irq nowait 3                    ; Signal to restore pindirs and tranceiver direction.

;-----------------------------------------------------------------------------------------
; Waits for data_dir to go high and then sets pindirs accordingly.
; Waits for interrupt signal before restoring.
;
; in and out pin mappings should be 1 bit starting at data_dir
; set pindir mapping should be 5 bits starting at D0
; side set mapping should be 3 bits starting at D5
;
; 5 instructions
;-----------------------------------------------------------------------------------------
.program set_pindirs
.side_set 3 opt pindirs				; The 3 bits are pindirs for D6-D8
	wait 1 pin 0    				; Wait on data_dir to go high (pin 22)
	set pindirs, 31 side 7			; Pindirs set to out for all 8 data bits. 74LVC245 transceiver should have reversed by now.
	wait 1 irq 3					; Wait for signal to reverse pindirs / tranceiver direction
	set pindirs, 0 side 0			; Restore all pindirs.
	mov pins, null					; Restore data_dir (tranceiver direction). Must not be before pindirs.
                                    ; Could be at same time however but would require using pindir / pull down to effect this.
                                    ; An option if we end up being an instruction over budget