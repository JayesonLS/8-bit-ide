; Test PIO program for outputting data with approximate ISA timing.
;
; Copyright (C) 2021 Titanium Studios Pty Ltd 
; 
; This program is free software : you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation, either version 3 of the License, or
; (at your option) any later version.
; 
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
; GNU General Public License for more details.
; 
; You should have received a copy of the GNU General Public License
; along with this program.If not, see < https://www.gnu.org/licenses/>.

; XTA Registers:
; 320 Read: Read data from drive
; 320 Write: Write data to drive
; 321 Read: Status register
;   Bit 7-6: Reserved
;   Bit 5: IRQ asserted
;   Bit 4: DRQ asserted
;   Bit 3: Busy
;   Bit 2: Control(0)/Data(1)
;   Bit 1: Output(0)/Input(1)
;   Bit 0: Request
; 321 Write: Reset. Data ignored.
; 322 Read: Configuration register
;   Bit 7: Unused?
;   Bit 6: WD jumper value? Check on drive.
;   Bit 5: WD jumper value? Check on drive.
;   Bit 4: WD jumper value? Check on drive.
;   Bit 3-2: Drive 0 config
;   Bit 1-0: Drive 1 config
;       XTA only supports one drive. Real XTA drives seem 
;       to report same value for both. 
; 322 Write: Select register (tells drive to prepare for command).
;       Data ignored.
; 323 Write: DMA/IRQ enable.
;   Bit 7-2: Reserved
;   Bit 1: IRQ enable
;   Bit 0: DMA enable
;   
; Proposed pin ordering
;        uint data : num_data_bits;
;        uint inv_dack : 1;
;        uint inv_iow : 1;
;        uint a0 : 1; 
;        uint a1 : 1;
;        uint inv_cs : 1;
;        uint aen : 1;
;        uint inv_ior : 1;
;        uint drq : 1;
;        uint irq : 1;
;        uint data_dir : 1; data_dir here in case we want to side-set it with drq and/or irq.
;
;        uint inv_reset : 1;

; Proposed allocations:
; PIO0 = data_write[_dma] (9 min) + write_control_regs (15) 
;      = 24 instructions min, 8 spare
; PIO1 = data_read[_dma] (6 min) + read_register_1 (10) + read_register_2 (8) + set_pindirs (5)
;      = 29 instructions min, 3 spare
; OR
; PIO1 = data_read[_dma] (6 min) + read_control_register (13) +  set_pindirs (5)
;      = 23 instructions min, 9 spare
; Second option seems best, we have a lot of room for latency reduction. Can possibly even
; squeeze in the DMA code without having to swap programs on the fly.

; Read setup times:
; Source 1: PC104 timings document, gives some huge number.
; Source 2: Tandy 1000SX setup time (8MHz bus), then subtract the 
;           difference for 3 clock cycles for 10MHz vs  8MHz bus.
;           Gives 192ns.
; Source 3: tOE/tDOE from WD1002S-WX2 disk controller manual.
;           Gives 175ns.
;
; At 125MHz, 8ns per instruction.
; Using max read setup time is 175ns = 21.875 cycles. 
; Subtract ~4 cycles for aliasing delay, two LVC propogation
; delays, and possibly one Pico pad propogation delay.
; Therefore max instructions to set up a read is ~18.
;
; For worst read setup latency below of 13 cycles, total delay
; is ~136ns.

;-----------------------------------------------------------------------------------------
; Non-DMA writes to data register. Simply writes values to the FIFO which will be DMA'ed
; into a memory buffer. The DMA controller will handle the interrupt when the transfer
; has completed.
;
; Program must be started at wait_for_write_start.
; 
; 9 instructions
;-----------------------------------------------------------------------------------------
.program data_write
write_value:
    push block                      ; Send the last value read before ~IOW went high.

wait_for_write_start:
    mov osr, pins                   ; Get current pin state
    mov isr, osr                    ; Save to previous value
    out null, 9                     ; Skip data and ~DACK
    out x, 5                        ; ~IOW, A0, A1, ~CS, AEN, to X (want all 0)
    jmp x--, wait_for_write_start
    
.wrap_target
    mov osr, pins
    jmp pin write_value             ; Break if ~IOW has gone high.
    mov isr, osr                    ; Update previous value
.wrap

;-----------------------------------------------------------------------------------------
; This approach to implementation requires the CPU to very quickly update
; the read value for register 1 to indicate busy. Should probably dedicate a CPU to this.
; TODO: We must start this program at the "wait 1 pin 10" line (one before the wrap target)
;
; Program start point is the wrap target. Y must initialized to something non-zero.
;
; 15 instructions.
;-----------------------------------------------------------------------------------------
.program write_control_register

not_320:
    jmp y-- not_321                 ; Jump if !0b0001
write_321:                          ; Y now 0xFFFFFFFF
    ; Write to address 1 is reset controller
    irq nowait 0				    ; Trigger reset interupt

    ; The control flow is a but confusing here. The jump will
    ; be taken on fall-through as Y will have been post-decremeneted 
    ; to 0xFFFFFFFF.
not_321:
    jmp y-- not_322                 ; Jump if not !b0010
write_322:                          ; Y now 0xFFFFFFFF
    ; Write to address 2 is select controller
    irq nowait 1				    ; Trigger select interrupt

    ; Fall through. Similar to aboive, Y will be 0xFFFFFFFF on fall-through

not_322:
    ; At this point Y will be zero only for write to 323

.wrap_target
wait_for_write_end:
    mov osr, pins                   ; Keep saving pin values until we see the end of the write.
    jmp pin write_end				; Break if ~IOW has gone high.
    mov isr, osr                    ; Update previous value
    jmp wait_for_write_end

write_end:
    jmp y-- wait_for_write_start    ; The only case where we can get here and Y is zero is for a write to 323.
write_323:                  
    ; TODO: Should we clear IRQ here if the value is cleared? Same for DRQ?
    push block						; Send the last value read before ~IOW went high.

wait_for_write_start:
    wait 0 pin 9                    ; Wait for ~IOW low
    mov osr, pins
    out null, 10					; Skip data, ~DACK, ~IOW
    out y, 4						; A0, A1, ~CS and AEN to Y (want 0b0001, 0b0010 or 0b0011)
    jmp y-- not_320                 ; Jump if !0b0000
.wrap                               ; Was 0b0000 so wrap. Y now 0xFFFFFFFF.

;-----------------------------------------------------------------------------------------
; Non-DMA reads from data register. Simply pulls a value and returns it on every read.
; The FIFO will be DMA fed and the DMA controller will handle the interrupt when the transfer
; has completed.
;
; Setup code should enable pullups on data lines in case there is 
; some way the tranceiver reverses without pindirs being set.
; Init X to FF as this will be the default value if the FIFO
; is read when empty
;
; 6 instructions. 7 cycles of latency.
;-----------------------------------------------------------------------------------------
.program data_read
.side_set 1 opt
wait_for_read_start:
    mov osr, pins                   ; in pins are configured to start at Address lines
    out y, 5                        ; Shift A1, A0, ~IOR, ~CS, AEN into Y (want all 0)
    jmp y--, wait_for_read_start

    ; Place data on the bus.
    pull noblock side 1             ; Get data, change tranceiver direction. set_pindirs program will set pin directions.
    out pins, 8                     ; Set data
    wait 1 pin 2					; Wait for ~IOR high. set_pindirs will take care of restoring pindirs and tranceiver dir.

;-----------------------------------------------------------------------------------------
; Combined read of either control register. Probably fine to use individual programs but
; writing it anyway to explore.
; Register 1 is the flags register, 2 is the configuration register.
;
; Program constantly pull from the FIFO to keep the status register value up to date.
;
; Program start point is one instructinon past the wrap target.
; X must initialized to the initial register read values (0 for example).
;
; 13 instructions. Up to 13 cycle delay (+ external delays) to set up read.
; See top of file for a discussion on max delays. 
;-----------------------------------------------------------------------------------------
.program read_control_register
.side_set 1 opt						; Side set maps to data_dir

not_320:
    jmp y-- not_321                 ; Jump on  !0b00001

read_321:
    mov isr, ~osr                   ; Copy with invert ~DRQ and ~IRQ still sitting in OSR (TODO: This inversion may not be necessary here - looks like it can be done with GPIOx_CTRL)
;NEW_BOARD    in x, 4	side 1					; Shift in the 4 status bits from X, reverse tranceiver direction (also signals pindir change)
    in x, 4	side 0 ;NEW_BOARD
;TODO: Remove:
    irq nowait 1				    ; Signal to CPU that we had a config register read so CPU can update the serial-ID bit in bit 7 of the config register

.wrap_target
    mov pins, isr					; (Setting tranceiver direction will result in other program setting pindirs)
    wait 1 pin 2					; Wait for ~IOR high. set_pindirs will take care of restoring pindirs and tranceiver dir

wait_for_read_start:
    pull noblock					; Keep read values up to date.
    mov x, osr						; If FIFO is empty, X is moved to OSR. So save read values in X.
    ; For 3 cycle lower worst case latency we can do a "jmp pin wait_for_read_start" here on ~IOR.
    mov osr, pins					; in pins are configured to start at address lines
    out y, 5						; Shift A0, A1, ~IOR, ~CS, AEN into Y 
                                    ; (want A1A0= 01 or 10, last 3 all 0)
    jmp y-- not_320                 ; Jump on  !0b00000

    ; Fall through. Y will have post-decremented to 0xFFFFFFFF
    ; and so the next jump will be taken.

not_321:
    jmp y-- wait_for_read_start     ; Jump on !0b00010

read_322:  
;NEW_BOARD    in  x, 16 side 1                ; Shift in data, skipping register_321's bits. Also reverse tranceiver direction/signals pindir change.
    in  x, 16 side 0 ;NEW_BOARD
    irq nowait 0				    ; Signal to CPU that we had a config register read so CPU can update the serial-ID bit in bit 7 of the config register
.wrap    

;-----------------------------------------------------------------------------------------
; Waits for data_dir to go high and then sets pindirs accordingly.
; Waits for ~IOR to go high, and then restores pindirs and then data_dir
;
; Program start point is the start of the program.
; X must be initalized to 0x00FF.
;
; 5 instructions
;-----------------------------------------------------------------------------------------
.program set_pindirs_alt
.side_set 1 opt				        ; The 1 bit is DATA_DIR
;NEW_BOARD    mov osr, x side 0               ; Get 0x00FF from X and restore data_dir to low 
;NEW_BOARD    wait 1 pin 7    				; Wait on data_dir to go high
    irq nowait 2				    ; Signal to CPU that we had a config register read so CPU can update the serial-ID bit in bit 7 of the config register
    mov osr, x side 1 ; NEW_BOARD
    nop
    nop
    wait 0 pin 7 ; NEW_BOARD
    irq nowait 3				    ; Signal to CPU that we had a config register read so CPU can update the serial-ID bit in bit 7 of the config register
    out pindirs, 8                  ; Pindirs set to out for all 8 data bits. 74LVC245 transceiver should have reversed by now.
;    wait 1 pin 4                    ; Wait for ~IOR high
    out pindirs, 8      			; Restore all pindirs to inputs 


.program set_pindirs_0
.side_set 1 opt				     
    nop side 0
    nop side 1

.program set_pindirs_1
.side_set 1 opt				  
    nop side 0
    wait 0 pin 0
    nop side 1
    wait 1 pin 0

.program set_pindirs_2
.side_set 1 opt				  
loop:
    nop side 0
wait_for_0:
    jmp pin wait_for_0
    nop side 1
.wrap_target
    jmp pin loop
.wrap

.program set_pindirs
.side_set 1 opt				  
    nop side 0
    //wait 0 gpio 22
    wait 0 pin 0
    irq 3
    nop side 1
    //wait 1 gpio 22
    wait 1 pin 0

.program set_pindirs_4
.side_set 1 opt				  
    irq 6 side 0
    wait 1 irq 6
    irq 7 side 1
    wait 1 irq 7

.program set_pindirs_5
.side_set 1 opt				  
    set pins 0
    wait 0 gpio 22
    set pins 1
    wait 1 gpio 22
